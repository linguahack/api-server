// Generated by CoffeeScript 1.8.0
(function() {
  var async, cheerio, fsto_common, request;

  async = require('async');

  cheerio = require('cheerio');

  request = require('request');

  fsto_common = require('../common/fsto');

  module.exports = this;

  this.append_to_schemas = function(schemas) {
    schemas.serial_schema.virtual("fsto.player_url").get(function() {
      return "http://fs.to/video/serials/view/" + this.fsto.id;
    });
    schemas.serial_schema.virtual("fsto.full_url").get(function() {
      return "http://fs.to/video/serials/" + this.fsto.id + "-" + this.fsto.url + ".html";
    });
    schemas.serial_schema.virtual("fsto.full_url").set(function(url) {
      var regex;
      regex = /serials\/([\da-zA-Z]*)-(.*)\.html/.exec(url);
      this.fsto.id = regex[1];
      return this.fsto.url = regex[2];
    });
    schemas.serial_schema.methods.fs_get_name_and_image = function(cb) {
      return request({
        url: this.fsto.full_url
      }, (function(_this) {
        return function(err, response, body) {
          var $;
          if (err) {
            cb(err);
            return;
          }
          $ = cheerio.load(body);
          _this.fsto.name = ($('div.b-tab-item__title-origin')).html();
          _this.fsto.image_url = ($('.poster-main img')).attr('src');
          return cb(null);
        };
      })(this));
    };
    schemas.serial_schema.methods.fs_common_query_string_params = function(folder_id) {
      var res;
      if (folder_id == null) {
        folder_id = 0;
      }
      return res = {
        ajax: 1,
        r: Math.random(),
        id: this.fsto.id,
        download: 1,
        view: 1,
        view_embed: 0,
        blocked: 0,
        folder_quality: null,
        folder_lang: null,
        folder_translate: null,
        folder: folder_id
      };
    };
    schemas.serial_schema.methods.fs_get_seasons = function(cb) {
      return request({
        url: this.fsto.full_url,
        qs: this.fs_common_query_string_params()
      }, (function(_this) {
        return function(err, response, body) {
          var $, link_name_regex, season_regex;
          if (err != null) {
            cb(err);
            return;
          }
          $ = cheerio.load(body);
          season_regex = /(\d+) сезон/;
          link_name_regex = /fl(\d+)/;
          ($('li.folder a.link-simple')).each(function(i, elem) {
            var id, season, season_number, _ref, _ref1;
            elem = $(elem);
            season_number = (_ref = season_regex.exec(elem.text())) != null ? _ref[1] : void 0;
            if (season_number) {
              id = (_ref1 = link_name_regex.exec(elem.attr('name'))) != null ? _ref1[1] : void 0;
              season = _this.find_or_create_season(season_number);
              return season.fsto = {
                folder_id: id
              };
            }
          });
          return cb(null);
        };
      })(this));
    };
    schemas.season_schema.methods.fs_get_translation = function(cb) {
      return request({
        url: this.parent().fsto.full_url,
        qs: this.parent().fs_common_query_string_params(this.fsto.folder_id)
      }, (function(_this) {
        return function(err, resp, body) {
          var $, elem, elem_id, link_name_regex, _ref;
          if (err != null) {
            cb(err);
            return;
          }
          if (resp.statusCode === 403) {
            cb({
              message: 'forbidden request to server',
              href: resp.request.url.href
            });
            return;
          }
          $ = cheerio.load(body);
          link_name_regex = /fl(\d+)/;
          elem = $('li.folder a.link-subtype.m-en');
          elem_id = (_ref = link_name_regex.exec(elem.attr('name'))) != null ? _ref[1] : void 0;
          if (elem_id == null) {
            console.log('cannot parse body', _this.parent().name, _this.number);
          }
          _this.fsto.en_folder_id = elem_id;
          return cb(null);
        };
      })(this));
    };
    schemas.season_schema.methods.fs_get_episodes = function(cb) {
      var season;
      season = this;
      return request({
        url: this.parent().fsto.full_url,
        qs: this.parent().fs_common_query_string_params(this.fsto.en_folder_id)
      }, (function(_this) {
        return function(err, resp, body) {
          var $, episodes_from_text, file_id_from_link_regex, quality, _i, _len, _ref;
          if (err != null) {
            cb(err);
            return;
          }
          file_id_from_link_regex = /file=(\d+)/;
          episodes_from_text = /Серия (\d+)/;
          $ = cheerio.load(body);
          _ref = ['hdtvrip', '720', '1080'];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            quality = _ref[_i];
            ($("li.video-" + quality + " a.b-file-new__link-material")).each(function(i, elem) {
              var episode, episode_number, file_id, _ref1, _ref2;
              elem = $(elem);
              file_id = (_ref1 = file_id_from_link_regex.exec(elem.attr('href'))) != null ? _ref1[1] : void 0;
              episode_number = (_ref2 = episodes_from_text.exec(elem.text())) != null ? _ref2[1] : void 0;
              if (episode_number != null) {
                episode = season.find_or_create_episode(episode_number);
                return episode.fsto.files.push({
                  quality: quality,
                  file_id: file_id
                });
              }
            });
          }
          return cb(null);
        };
      })(this));
    };
    schemas.fsto_file_schema.methods.get_link = function(cb) {
      if ((this.last_updated != null) && new Date - this.last_updated < 60000) {
        cb(null);
        return;
      }
      return fsto_common.get_link({
        fs_file: this,
        serial: this.ownerDocument(),
        season: this.parent().parent()
      }, cb);
    };
    schemas.serial_schema.methods.fs_update_links = function(cb) {
      var e, f, s, tasks, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      tasks = [];
      _ref = this.seasons;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        _ref1 = s.episodes;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          e = _ref1[_j];
          _ref2 = e.fsto.files;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            f = _ref2[_k];
            tasks.push(f.get_link.bind(f));
          }
        }
      }
      return async.series(tasks, cb);
    };
    schemas.serial_schema.statics.fs_serial_from_url = function(url, cb) {
      var serial, tasks;
      serial = new this;
      serial.fsto.full_url = url;
      tasks = [serial.fs_get_name_and_image.bind(serial), serial.fs_get_seasons.bind(serial)];
      return async.series(tasks, function() {
        var season, _i, _len, _ref;
        tasks = [];
        _ref = serial.seasons;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          season = _ref[_i];
          tasks.push(season.fs_get_translation.bind(season));
          tasks.push(season.fs_get_episodes.bind(season));
        }
        tasks.push(serial.fs_update_links.bind(serial));
        tasks.push(serial.save.bind(serial));
        return async.series(tasks, cb);
      });
    };
    return schemas.serial_schema.statics.fs_serial_from_urls = function(urls, cb) {
      return async.each(urls, this.fs_serial_from_url.bind(this), cb);
    };
  };

}).call(this);
